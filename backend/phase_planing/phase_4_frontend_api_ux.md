# Phase 4: Frontend API Contract & UX Execution Guide (Aligned to Current Backend)

This document instructs a frontend agent on how to integrate with the existing FastAPI backend. It specifies:
- Exact REST endpoints currently available
- Request/response shapes aligned to backend Pydantic models
- Polling strategies (no WebSockets implemented)
- UX behavior rules and flows that match current backend capability
- Limitations and placeholders for future features

Base URL and Versioning
- Base URL: http(s)://<host>:<port>/api/v1
- Health endpoints:
  - GET /api/v1/status/health → HealthResponse
  - GET /api/v1/status → basic API status

CORS and Security
- CORS is enabled; allowed origins are controlled by server settings.
- There is no authentication/authorization yet. Treat as anonymous development mode. Do not expose secrets in client code.

Key Enums (from backend/app/models/enums.py)
- DatasetSource: "GEO" | "PRIDE" | "ENSEMBL" | "INTERNAL"
- AccessType: "public" | "request" | "restricted"
- TaskStatus: "pending" | "running" | "completed" | "failed"
- TaskType: "search" | "find_contact" | "send_email"
- OutreachStatus: "draft" | "queued" | "sent" | "delivered" | "replied" | "closed"

Implemented Endpoints and Contracts

1) Health and Status
- GET /api/v1/status/health
  - Response (HealthResponse):
    {
      "status": "healthy",
      "version": string,
      "timestamp": ISO8601
    }

- GET /api/v1/status
  - Response:
    {
      "status": "online",
      "version": string,
      "app_name": string,
      "timestamp": ISO8601,
      "debug_mode": boolean
    }

2) Search Workflow (backend/app/api/v1/search.py)
- POST /api/v1/search
  - Body (SearchRequest):
    {
      "query": string,
      "modalities": string[] | null,
      "cancer_types": string[] | null,
      "sources": ("GEO"|"PRIDE"|"ENSEMBL"|"INTERNAL")[] | null,
      "include_internal": boolean,
      "max_results": number (1..100, default 20)
    }
  - Response (SearchResponse):
    {
      "task_id": string,
      "status": "pending" | "running" | "completed" | "failed",
      "message": string
    }

- GET /api/v1/search/{task_id}
  - Response (TaskResponse):
    {
      "id": string,
      "type": string,                       // e.g., "search"
      "status": "pending"|"running"|"completed"|"failed",
      "user_email": string | null,
      "input_data": object | null,          // original SearchRequest
      "output_data": object | null,         // populated when completed
      "error_message": string | null,
      "created_at": ISO8601,
      "started_at": ISO8601 | null,
      "completed_at": ISO8601 | null
    }

- GET /api/v1/search/{task_id}/results
  - Response:
    {
      "task_id": string,
      "status": string,            // TaskStatus value
      "results": object | [],      // equals Task.output_data (see below), or []
      "completed_at": ISO8601 | null
    }

Output Data Shape (Task.output_data)
Produced by Agent Orchestrator (backend/app/core/agent_orchestrator.py):
{
  "plan": object,
  "datasets": DatasetCandidateLike[],
  "contacts": InternalContactLike[],
  "outreach": OutreachAttempt[],
  "summary": object
}

DatasetCandidateLike (normalized by bio_database_agent)
{
  "accession": string,
  "title": string,
  "description": string | null,
  "modalities": string[],
  "cancer_types": string[],
  "sample_size": number | null,
  "access_type": "public" | "request" | "restricted",
  "download_url": string | null,
  "contact_info": { "name"?: string, "email"?: string } | null,
  "link": string | null,
  "relevance_score": number
}

InternalContactLike (from colleagues_agent)
{
  "name": string,
  "email": string | null,
  "job_title": string,
  "department": string | null,
  "linkedin_url": string | null,
  "relevance_score": number,
  "reason_for_contact": string
}

3) Datasets (backend/app/api/v1/datasets.py)
- GET /api/v1/datasets?skip=0&limit=20&source=GEO&access_type=public
  - Response: DatasetResponse[]
  - DatasetResponse:
    {
      "id": string,
      "source": "GEO"|"PRIDE"|"ENSEMBL"|"INTERNAL",
      "accession": string | null,
      "title": string,
      "description": string | null,
      "modalities": string[],
      "cancer_types": string[],
      "organism": string | null,
      "sample_size": number | null,
      "download_url": string | null,
      "access_type": "public"|"request"|"restricted",
      "owner_email": string | null,
      "owner_name": string | null,
      "publication_url": string | null,
      "extra_metadata": object | null,
      "created_at": ISO8601,
      "updated_at": ISO8601 | null
    }

- GET /api/v1/datasets/{dataset_id} → DatasetResponse
- POST /api/v1/datasets → DatasetResponse (create)
- PUT /api/v1/datasets/{dataset_id} → DatasetResponse (update)
- DELETE /api/v1/datasets/{dataset_id} → { "message": "Dataset deleted successfully" }

Note: Search results are generated by agents and are not automatically persisted. Use POST /datasets if you need to save items.

4) Outreach (backend/app/api/v1/outreach.py)
- GET /api/v1/outreach?skip=0&limit=20&status=replied&requester_email=user@example.com
  - Response: OutreachResponse[]
  - OutreachResponse:
    {
      "id": string,
      "dataset_id": string,
      "requester_email": string,
      "requester_name": string | null,
      "contact_email": string,
      "contact_name": string | null,
      "status": "draft"|"queued"|"sent"|"delivered"|"replied"|"closed",
      "email_subject": string | null,
      "email_body": string | null,
      "created_at": ISO8601,
      "sent_at": ISO8601 | null
    }

- GET /api/v1/outreach/{id} → OutreachResponse

- POST /api/v1/outreach
  - Body:
    {
      "dataset_id": string,
      "requester_email": string,
      "requester_name": string,
      "contact_email": string,
      "contact_name": string | null,
      "email_subject": string,
      "email_body": string,
      "approval_required": boolean
    }
  - Response: OutreachResponse (status begins as "draft")

- POST /api/v1/outreach/{id}/send
  - Response:
    {
      "message": "Outreach request queued for sending",
      "outreach_id": string,
      "status": "queued"
    }
  Current behavior: marks the record as queued. Delivery/reply updates arrive via webhook (below) and should be observed by polling.

- PUT /api/v1/outreach/{id}/status?status={OutreachStatus}
  - Response:
    {
      "message": "Outreach status updated successfully",
      "outreach_id": string,
      "status": string
    }
  For admin/manual updates. Production status transitions come from the webhook.

5) Tasks (backend/app/api/v1/tasks.py)
- GET /api/v1/tasks?skip=0&limit=20&task_type=search&status=completed&user_email=...
  → TaskResponse[]

- GET /api/v1/tasks/{task_id} → TaskResponse

- DELETE /api/v1/tasks/{task_id}
  → { "message": "Task cancelled successfully" }
  Cancels only pending/running tasks; others return 400.

- GET /api/v1/tasks/{task_id}/logs
  → { "task_id": string, "logs": [{ "timestamp": ISO8601, "level": "INFO", "message": string }] }
  Placeholder logs (will expand in future).

6) Webhooks (Server-To-Server; FYI for Frontend)
- POST /api/v1/webhooks/agentmail/webhook
  Used by AgentMail to push:
  - "message.received" → sets outreach status to "replied", updates replied_at; flags approval_required if attachments exist
  - "message.delivered" → sets outreach status to "delivered"
  - "message.bounced" → sets outreach status to "closed"
  Frontend should not call this. Reflect updates by polling GET /api/v1/outreach.

Unavailable or Deferred Endpoints
- Authentication:
  - NOT IMPLEMENTED: /api/v1/auth/login, /api/v1/auth/me
  - For now, operate as anonymous session. If a “user_email” is needed for filtering (e.g., tasks), store it in local app settings.

- WebSockets:
  - NOT IMPLEMENTED
  - Use polling strategy below.

- Contacts CRUD:
  - NOT IMPLEMENTED
  - Contacts returned as part of search results only (display-only).

- Export/Reports:
  - NOT IMPLEMENTED (no /export or /reports endpoints)
  - Hide or mark as “Coming soon”.

Frontend Agent Behavior

Search Flow (Initiate → Poll → Read Results)
1) POST /api/v1/search with SearchRequest
2) Poll GET /api/v1/search/{task_id} every 2 seconds until status ∈ {completed, failed}
3) On completed, GET /api/v1/search/{task_id}/results
4) Render datasets (from results.datasets) and contacts (results.contacts)
5) Optionally “Save” datasets via POST /api/v1/datasets

Dataset Cards
- Show: source, accession, title, description (expandable), modalities, cancer_types, sample_size, access_type, download_url/link, contact_info
- Relevance score: if present; otherwise hide or compute a simple client-side heuristic
- Primary actions:
  - Request Access → open outreach modal to compose email
    a) POST /api/v1/outreach (approval_required set based on your gating rules)
    b) POST /api/v1/outreach/{id}/send (queues the email)
    c) Poll outreach list/status to reflect transitions
  - Save → POST /api/v1/datasets (optional, to persist)

Outreach Management UI
- List/filter via GET /api/v1/outreach (status, requester_email)
- Approvals:
  - approval_required boolean indicates need for human review. Actual server-side enforcement is minimal; treat it as a UI gate before sending.
- Status and Replies:
  - The webhook updates status. The frontend should poll outreach list (every 10 seconds) while viewing the page or if there are queued/sent items.

Polling Strategy (No WebSockets)
- Active search task: GET /api/v1/search/{task_id} every 2s
- Outreach list: GET /api/v1/outreach every 10s (only when relevant UI is visible or there are items in queued/sent states)
- Tasks overview: GET /api/v1/tasks every 10s while viewing the tasks page
- Stop polling when no active items are pending or when the tab is not visible

Errors and Feedback (Backend ErrorResponse)
- Common response:
  {
    "detail": string,
    "error_code": string | null,
    "timestamp": ISO8601
  }
- HTTP 404 → “Not found” toast
- HTTP 400 → inline form error
- HTTP 500 → modal dialog with retry option
- Network/timeouts → yellow banner with retry
- Show progress spinners during polling and disable duplicate-action buttons

Concrete Examples (Axios)

Base client
```ts
const api = axios.create({
  baseURL: `${import.meta.env.VITE_API_URL}/api/v1`,
  timeout: 30000,
  headers: { "Content-Type": "application/json" }
});
```

Start search
```ts
const { data } = await api.post("/search", {
  query: "P53 mutations in lung adenocarcinoma",
  modalities: ["transcriptomics"],
  cancer_types: ["lung adenocarcinoma"],
  sources: ["GEO"],
  include_internal: true,
  max_results: 20
});
// data: { task_id, status, message }
```

Poll task
```ts
const task = await api.get(`/search/${data.task_id}`);
// task.data.status in ["pending","running","completed","failed"]
```

Fetch results
```ts
const res = await api.get(`/search/${data.task_id}/results`);
// res.data.results = { plan, datasets, contacts, outreach, summary }
```

List datasets (persisted)
```ts
const list = await api.get("/datasets", { params: { skip: 0, limit: 20, source: "GEO", access_type: "public" } });
```

Create outreach, then send
```ts
const created = await api.post("/outreach", {
  dataset_id: "GSE12345",
  requester_email: "you@example.com",
  requester_name: "You",
  contact_email: "custodian@lab.org",
  contact_name: "Dr. Smith",
  email_subject: "Request for access to GSE12345",
  email_body: "…",
  approval_required: false
});
await api.post(`/outreach/${created.data.id}/send`);
```

Observe status
```ts
// Poll /outreach?requester_email=you@example.com to observe QUEUED → SENT → DELIVERED → REPLIED
```

UI/UX Requirements (Feasible Today)

Dashboard
- Search bar submits to POST /api/v1/search
- Activity feed driven by polling /tasks and /outreach
- Stats: compute counts from polled data (active searches = tasks with status ∈ {pending,running})

Search Progress View
- Show TaskStatus and progress bar
- Provide “Cancel” → DELETE /api/v1/tasks/{task_id}
- On completion, show results and link to outreach actions

Dataset Cards
- Use accession/title as identifiers (if persisted, use id)
- Actions: Request Access, Save (optional)
- Badges: Access Type, Source

Outreach Table
- Columns: Dataset (accession/title), Contact, Status, Sent at, Actions (View)
- View: side panel showing subject/body from OutreachResponse; no thread API available

Accessibility and Performance
- Keyboard navigable controls
- Pagination for dataset list (skip/limit)
- Avoid frequent polling when tab inactive
- Throttle polling intervals on low-activity views

Limitations and “Coming Soon”
- No authentication (hide role-based UI)
- No websockets (use polling)
- No contact management CRUD
- No export/report endpoints
- No email thread retrieval API

Appendix: Types from Backend (Reference)
- See backend/app/models/schemas.py for exact Pydantic models used in responses (DatasetResponse, SearchResponse, TaskResponse, OutreachResponse, ErrorResponse).
- See backend/app/models/enums.py for enum values expected by query parameters and responses.
